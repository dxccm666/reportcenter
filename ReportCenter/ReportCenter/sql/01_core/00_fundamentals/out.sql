/* 
	USERS TABLE 
*/
CREATE SEQUENCE USERSEQ;

CREATE TABLE USERS (
	ID VARCHAR2(10) NOT NULL, 
	ROWSTAMP VARCHAR2(10) NOT NULL,
	USERLOGIN VARCHAR2(100),
	FULLNAME VARCHAR2(200),
	SORTNAME VARCHAR2(200),
	EMPLID VARCHAR(20),
	PASSWORD VARCHAR2(64),
	ISACTIVE NUMBER(1) DEFAULT 1 NOT NULL,
	SECRETKEY VARCHAR2(10),
	CREATED DATE,
	CREATEDBY VARCHAR2(10),
	PRIMARY KEY (ID),
	CONSTRAINT USERS_U1 UNIQUE (USERLOGIN)
);

CREATE INDEX USERS_IDX1 ON USERS (USERLOGIN, ISACTIVE);

CREATE OR REPLACE TRIGGER USERS_T 
BEFORE INSERT OR UPDATE ON USERS
FOR EACH ROW
DECLARE 
	OBJECTMODIFICATION EXCEPTION;
	INVALIDDATA EXCEPTION;
BEGIN
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;

	IF INSERTING THEN 
		SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.SECRETKEY FROM DUAL;
	END IF;
	
	SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;
	EXCEPTION 
	   WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
	   WHEN INVALIDDATA THEN
	    RAISE_APPLICATION_ERROR(-20099,'Invalid Data');
END;
/

/* 
	CAMPUSES 

	DEFINES PARTICULAR CAMPUS VALUES. 
	MOSTLY DEFINED TO ALLOW FOREIGN KEY CONSTRAINTS TO LATER TABLES TO BE ADDED.
	MAY ADD FIELDS AS NECESSARY.
	
	Should we rename this campuses so as not to conflict with ARCHIBUS data?
	
	If we sell projex rename to Organizations.
*/

CREATE SEQUENCE CAMPUSSEQ;

CREATE TABLE CAMPUSES (
	ID VARCHAR2(10) NOT NULL,
	ROWSTAMP VARCHAR2(10) NOT NULL,
	CAMPUS VARCHAR2(20) NOT NULL, 
	DESCRIPTION VARCHAR2(100) NOT NULL,
	ISACTIVE NUMBER(1) DEFAULT 1 NOT NULL,
	PRIMARY KEY (ID),
	CONSTRAINT CAMPUSES_U UNIQUE (CAMPUS)
);

CREATE OR REPLACE TRIGGER CAMPUSES_T 
BEFORE INSERT OR UPDATE ON CAMPUSES
FOR EACH ROW
DECLARE 
	OBJECTMODIFICATION EXCEPTION;
BEGIN
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;

	SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;
	EXCEPTION 
	   WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
END;
/

CREATE MATERIALIZED VIEW LOG ON CAMPUSES PARALLEL WITH ROWID, SEQUENCE(CAMPUS, ISACTIVE), PRIMARY KEY INCLUDING NEW VALUES;

/* Lists for general use */

CREATE SEQUENCE LISTSEQ;

CREATE TABLE LISTS (
	ID VARCHAR2(10) NOT NULL,
	ROWSTAMP VARCHAR2(10) NOT NULL,
	LISTNAME VARCHAR2(100) NOT NULL,
	DESCRIPTION VARCHAR2(500) NOT NULL,
	HELPTEXT VARCHAR2(500),
	ISACTIVE NUMBER(1) DEFAULT 1 NOT NULL,
	ISSYSTEM NUMBER(1) DEFAULT 0 NOT NULL,
	PRIMARY KEY (ID),
	CONSTRAINT SETS_U UNIQUE (LISTNAME)
);

COMMENT ON TABLE LISTS IS 'GENERALLY USABLE VALUE LISTS'
/

COMMENT ON COLUMN LISTS.LISTNAME IS 'NAME OF VALUE LIST - IF SUBLIST, NAME SHOULD BE PARENTNAME.SUBLISTNAME'
/

COMMENT ON COLUMN LISTS.ISACTIVE IS 'THIS LIST IS USABLE - IF SET TO 0 VALUE LISTS WILL NOT POPULATE'
/

COMMENT ON COLUMN LISTS.ISSYSTEM IS 'THIS LIST IS REQUIRED BY THE SYSTEM TO OPERATE'
/

COMMENT ON COLUMN LISTS.DESCRIPTION IS 'BRIEFLY DESCRIBES WHAT LIST IS USED FOR'
/

CREATE OR REPLACE TRIGGER LISTS_T 
BEFORE INSERT OR UPDATE ON LISTS
FOR EACH ROW
DECLARE 
	OBJECTMODIFICATION EXCEPTION;
BEGIN
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;

	SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;
	EXCEPTION 
	   WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
END;
/

CREATE INDEX LISTS_IDX1 ON LISTS (LISTNAME, ISACTIVE);
/* 
	LISTITEMS 

	PROVIDES VALUES FOR DROP DOWN LISTS 
*/
CREATE SEQUENCE LISTITEMSEQ;

DROP TABLE LISTITEMS;

CREATE TABLE LISTITEMS (
	ID VARCHAR2(10) NOT NULL,
	ROWSTAMP VARCHAR2(10) NOT NULL,
	LISTID VARCHAR2(10) NOT NULL,
	ISALLCAMPUS NUMBER(1) NOT NULL,
	CAMPUSID VARCHAR2(10),
	DISPLAYORDER NUMBER(5) NOT NULL,
	SYSTEMVALUE VARCHAR2(100) NOT NULL,
	VALUE VARCHAR2(100) NOT NULL,
	ISDEFAULT NUMBER(1) DEFAULT 0 NOT NULL,
	DESCRIPTION VARCHAR2(500),
	PRIMARY KEY (ID),
	CONSTRAINT LISTITEMS_U UNIQUE (LISTID, SYSTEMVALUE, VALUE),
	CONSTRAINT LISTITEMS_FK1 FOREIGN KEY (LISTID) REFERENCES LISTS (ID)
);

CREATE OR REPLACE TRIGGER LISTITEMS_T 
BEFORE INSERT OR UPDATE ON LISTITEMS
FOR EACH ROW
DECLARE 
	OBJECTMODIFICATION EXCEPTION;
BEGIN
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;
	SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;
	EXCEPTION 
	   WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
END;
/

CREATE INDEX LISTITEMS_IDX1 ON LISTITEMS (LISTID);
CREATE INDEX LISTITEMS_IDX2 ON LISTITEMS (ISALLCAMPUS);
CREATE INDEX LISTITEMS_IDX3 ON LISTITEMS (ISDEFAULT);
CREATE SEQUENCE USERLOGINHISTORYSEQ;
CREATE TABLE USERLOGINHISTORY (
	ID VARCHAR2(10),
	USERID VARCHAR2(10),
	LOGGEDIN TIMESTAMP,
	IPADDRESS VARCHAR2(30),
	PRIMARY KEY (ID),
	CONSTRAINT USERLOGINHISTORY_FK1 FOREIGN KEY (USERID) REFERENCES USERS (ID)
);

CREATE INDEX USERLOGINHISTORY_IDX1 ON USERLOGINHISTORY (USERID);
CREATE INDEX USERLOGINHISTORY_IDX2 ON USERLOGINHISTORY (LOGGEDIN);
CREATE INDEX USERLOGINHISTORY_IDX3 ON USERLOGINHISTORY (USERID, LOGGEDIN);


CREATE SEQUENCE CAMPUSUSERSEQ;

CREATE TABLE CAMPUSUSERS(
	ID VARCHAR2(10) NOT NULL,
	ROWSTAMP VARCHAR2(10) NOT NULL,
	CAMPUSID VARCHAR2(10) NOT NULL,
	USERID VARCHAR2(10) NOT NULL,
	PRIMARY KEY (ID),
	CONSTRAINT CAMPUSUSER_U UNIQUE (CAMPUSID, USERID),
	CONSTRAINT CAMPUSUSER_FK1 FOREIGN KEY (CAMPUSID) REFERENCES CAMPUSES (ID),
	CONSTRAINT CAMPUSUSER_FK2 FOREIGN KEY (USERID) REFERENCES USERS (ID)
);

CREATE OR REPLACE TRIGGER CAMPUSUSERS_T
BEFORE INSERT OR UPDATE ON CAMPUSUSERS
FOR EACH ROW
DECLARE
     OBJECTMODIFICATION EXCEPTION;
BEGIN
     IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
	     RAISE OBJECTMODIFICATION;
     END IF;

     SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;

     EXCEPTION
	WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
END;
/

CREATE INDEX CAMPUSUSERS_IDX1 ON CAMPUSUSERS (USERID) NOLOGGING;
CREATE INDEX CAMPUSUSERS_IDX2 ON CAMPUSUSERS (CAMPUSID) NOLOGGING;
CREATE SEQUENCE CRONTASKSEQ;
CREATE TABLE CRONTASKS (
	ID VARCHAR2(10) NOT NULL,
	ROWSTAMP VARCHAR2(10) NOT NULL,
	JAVACLASS VARCHAR2(2000) NOT NULL,
	DESCRIPTION VARCHAR2(500) NOT NULL,
	CRONEXPRESSION VARCHAR2(200) NOT NULL,
	ISACTIVE NUMBER(1) DEFAULT 0 NOT NULL,
	PRIMARY KEY (ID),
	CONSTRAINT CRONTASKS_U UNIQUE (JAVACLASS, CRONEXPRESSION)
);

CREATE OR REPLACE TRIGGER CRONTASKS_T 
BEFORE INSERT OR UPDATE ON CRONTASKS
FOR EACH ROW
DECLARE 
	OBJECTMODIFICATION EXCEPTION;
BEGIN
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;

	SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;
	EXCEPTION 
	   WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
END;
/

CREATE INDEX CRONTASKS_IDX1 ON CRONTASKS (ISACTIVE);
CREATE SEQUENCE CRONTASKRUNSEQ;

CREATE TABLE CRONTASKRUNS (
	ID VARCHAR2(10) NOT NULL,
	JAVACLASS VARCHAR2(2000) NOT NULL,
	SERVER VARCHAR2(1000) NOT NULL,
	RUNSTART TIMESTAMP NOT NULL,
	RUNEND TIMESTAMP NOT NULL,
	STATUS VARCHAR2(100) NOT NULL,
	ERROR VARCHAR2(500),
	PRIMARY KEY (ID)
);

CREATE INDEX CRONTASKRUNS_IDX1 ON CRONTASKRUNS (JAVACLASS);
CREATE INDEX CRONTASKRUNS_IDX2 ON CRONTASKRUNS (RUNSTART);
CREATE INDEX CRONTASKRUNS_IDX3 ON CRONTASKRUNS (STATUS);
/*
	SECURITYGROUPS
	
	SECURITYGROUPS ARE COLLECTIONS OF USERS NOT PERSONS - 
	SECURITY IS APPLIED FOR THE USER IN A MORE GLOBAL FASHION.


	INDIVIDUALS MAY HAVE SPECIAL RIGHTS JUST FOR THEM.

*/

CREATE SEQUENCE SECURITYGROUPSEQ;

CREATE TABLE SECURITYGROUPS (
	ID VARCHAR2(10) NOT NULL, 
	ROWSTAMP VARCHAR2(10) NOT NULL,
	SECURITYGROUPNAME VARCHAR2(50) NOT NULL,
	DESCRIPTION VARCHAR2(200) NOT NULL,
	ISACTIVE NUMBER(1) DEFAULT 1 NOT NULL,
	MODIFIED DATE NOT NULL,
	PRIMARY KEY (ID),
	CONSTRAINT SECURITYGROUPS_U UNIQUE (SECURITYGROUPNAME)
);

CREATE OR REPLACE TRIGGER SECURITYGROUPS_T 
BEFORE INSERT OR UPDATE ON SECURITYGROUPS
FOR EACH ROW
DECLARE 
	OBJECTMODIFICATION EXCEPTION;
BEGIN
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;

	SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;
	EXCEPTION 
	   WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
END;
/

/* 
	SECURITYGROUPUSERS

	ASSOCIATE USERS INTO SECURITYGROUPS 
	PK FROM SECURITYGROUPUSERSEQ;
*/
CREATE SEQUENCE SECURITYGROUPUSERSEQ;
CREATE TABLE SECURITYGROUPUSERS (
	ID VARCHAR2(10) NOT NULL, 
	ROWSTAMP VARCHAR2(10) NOT NULL,
	SECURITYGROUPID VARCHAR2(10) NOT NULL,
	USERID VARCHAR2(10) NOT NULL,
	CREATED DATE NOT NULL,
	PRIMARY KEY (ID),
	CONSTRAINT SECURITYGROUPUSERS_U UNIQUE (SECURITYGROUPID, USERID),
	CONSTRAINT SECURITYGROUPUSERS_FK1 FOREIGN KEY (SECURITYGROUPID) REFERENCES SECURITYGROUPS (ID),
	CONSTRAINT SECURITYGROUPUSERS_FK2 FOREIGN KEY (USERID) REFERENCES USERS (ID)
);

CREATE OR REPLACE TRIGGER SECURITYGROUPUSERS_T 
BEFORE INSERT OR UPDATE ON SECURITYGROUPUSERS
FOR EACH ROW
DECLARE 
	OBJECTMODIFICATION EXCEPTION;
BEGIN
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;
	SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;
	EXCEPTION 
	   WHEN OBJECTMODIFICATION THEN
		RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
END;
/

CREATE INDEX SECURITYGROUPUSERS_IDX1 ON SECURITYGROUPUSERS (SECURITYGROUPID);
CREATE INDEX SECURITYGROUPUSERS_IDX2 ON SECURITYGROUPUSERS (USERID);



CREATE SEQUENCE PROPERTYSEQ;
CREATE TABLE PROPERTIES (
	ID VARCHAR2(10) NOT NULL,
	ROWSTAMP VARCHAR2(10) NOT NULL,
	REFIDTYPE VARCHAR2(20) NOT NULL,
	REFID VARCHAR2(10),
	PROPERTY VARCHAR2(500) NOT NULL,
	VALUE VARCHAR2(500),
	PRIMARY KEY (ID)
);

CREATE OR REPLACE TRIGGER PROPERTIES_T 
BEFORE INSERT OR UPDATE ON PROPERTIES
FOR EACH ROW
DECLARE
	C NUMBER;
	OBJECTMODIFICATION EXCEPTION;
	INVALIDREFERENCE EXCEPTION;
BEGIN
	
	IF UPDATING AND NOT :NEW.ROWSTAMP = :OLD.ROWSTAMP THEN
		RAISE OBJECTMODIFICATION;
	END IF;
	
	C := 0;
	
	SELECT 1 INTO C FROM DUAL WHERE 
		(:NEW.REFIDTYPE = 'SYSTEM' AND :NEW.REFID IS NULL) OR
		(:NEW.REFIDTYPE = 'CAMPUS' AND EXISTS (SELECT ID FROM CAMPUSES WHERE ID = :NEW.REFID AND ISACTIVE = 1)) OR
		(:NEW.REFIDTYPE = 'USER' AND EXISTS (SELECT ID FROM USERS WHERE ID = :NEW.REFID AND ISACTIVE = 1)) OR
		(:NEW.REFIDTYPE = 'SECURITYGROUP' AND EXISTS (SELECT ID FROM SECURITYGROUPS WHERE ID = :NEW.REFID AND ISACTIVE = 1));
		
	IF NOT C = 1 THEN
		RAISE INVALIDREFERENCE;
	END IF;

    SELECT DBMS_RANDOM.STRING('U',10) INTO :NEW.ROWSTAMP FROM DUAL;

	EXCEPTION 
		WHEN OBJECTMODIFICATION THEN
			RAISE_APPLICATION_ERROR(-20100,'Record has been modified by another user');
		WHEN INVALIDREFERENCE THEN
			RAISE_APPLICATION_ERROR(-20003,'Invalid Reference ID');
	   
END;
/
CREATE OR REPLACE PACKAGE CORE AS

FUNCTION CAMPUS(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VCAMPUS IN VARCHAR2, 
	VDESCRIPTION IN VARCHAR2, VISACTIVE IN NUMBER) RETURN VARCHAR2;

PROCEDURE CAMPUS (VCAMPUS IN VARCHAR2, VDESCRIPTION IN VARCHAR2, 
	VISACTIVE IN NUMBER); 

FUNCTION LIST (VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VLISTNAME IN VARCHAR2, 
	VDESCRIPTION IN VARCHAR2, VHELPTEXT IN VARCHAR2, VISACTIVE IN NUMBER, 
	VISSYSTEM IN NUMBER) RETURN VARCHAR2;

PROCEDURE LIST (VLISTNAME IN VARCHAR2, VDESCRIPTION IN VARCHAR2, 
	VHELPTEXT IN VARCHAR2, VISACTIVE IN NUMBER, VISSYSTEM IN NUMBER);

FUNCTION LISTITEM (VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VLISTID IN VARCHAR2,
	VISALLCAMPUS IN NUMBER, VCAMPUSID IN VARCHAR2, VDISPLAYORDER IN NUMBER, VSYSTEMVALUE IN VARCHAR2, 
	VVALUE IN VARCHAR2, VISDEFAULT IN NUMBER, VDESCRIPTION IN VARCHAR2) RETURN VARCHAR2;


PROCEDURE LISTITEM (VLISTNAME IN VARCHAR2, VCAMPUS IN VARCHAR2, 
	VISALLCAMPUS IN NUMBER, VDISPLAYORDER IN NUMBER, 
	VSYSTEMVALUE IN VARCHAR2, VVALUE IN VARCHAR2, VISDEFAULT IN NUMBER, 
	VDESCRIPTION IN VARCHAR2); 

FUNCTION USER(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VUSERLOGIN IN VARCHAR2,  
	VFULLNAME IN VARCHAR2, VSORTNAME IN VARCHAR2, VEMPLID IN VARCHAR2,
	VPASSWORD IN VARCHAR2, VISACTIVE IN NUMBER, VSECRETKEY IN VARCHAR2, 
	VCREATED IN DATE, VCREATEDBY IN VARCHAR2) RETURN VARCHAR2;

PROCEDURE USER(VUSERLOGIN IN VARCHAR2,  
	VFULLNAME IN VARCHAR2, VSORTNAME IN VARCHAR2, VEMPLID IN VARCHAR2,
	VPASSWORD IN VARCHAR2, VISACTIVE IN NUMBER, VSECRETKEY IN VARCHAR2);

FUNCTION USERLOGINHISTORY(VID IN VARCHAR2, VUSERID IN VARCHAR2, 
	VLOGGEDIN IN TIMESTAMP, VIPADDRESS IN VARCHAR2) RETURN VARCHAR2;
	
FUNCTION CAMPUSUSER( VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, 
	VCAMPUSID IN VARCHAR2, VUSERID IN VARCHAR2) RETURN VARCHAR2;

PROCEDURE CAMPUSUSER(VCAMPUS IN VARCHAR2, VUSERLOGIN in VARCHAR2);

FUNCTION CRONTASK(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VJAVACLASS IN VARCHAR2, 
	VDESCRIPTION IN VARCHAR2, VCRONEXPRESSION IN VARCHAR2, 
	VISACTIVE IN NUMBER) RETURN VARCHAR2;

PROCEDURE CRONTASK(VJAVACLASS IN VARCHAR2, VDESCRIPTION IN VARCHAR2, 
	VCRONEXPRESSION IN VARCHAR2, VISACTIVE IN NUMBER);

FUNCTION CRONTASKRUN(VID IN VARCHAR2, VJAVACLASS IN VARCHAR2, VSERVER IN VARCHAR2, 
	VRUNSTART IN TIMESTAMP, VRUNEND IN TIMESTAMP, VSTATUS IN VARCHAR2, 
	VERROR IN VARCHAR2) RETURN VARCHAR2;

FUNCTION SECURITYGROUP ( VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, 
	VSECURITYGROUPNAME IN VARCHAR2, VDESCRIPTION IN VARCHAR2, 
	VISACTIVE IN NUMBER) RETURN VARCHAR2;

PROCEDURE SECURITYGROUP(VSECURITYGROUPNAME IN VARCHAR2, 
	VDESCRIPTION IN VARCHAR2, VISACTIVE IN NUMBER);

FUNCTION SECURITYGROUPUSER(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, 
	VSECURITYGROUPID IN VARCHAR2, VUSERID IN VARCHAR2) RETURN VARCHAR2;

PROCEDURE SECURITYGROUPUSER(VSECURITYGROUPNAME IN VARCHAR2, VUSERLOGIN IN VARCHAR2);


FUNCTION PROPERTY (VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VREFIDTYPE IN VARCHAR2, VREFID in VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2) RETURN VARCHAR2;

PROCEDURE SYSTEMPROPERTY(VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2);
PROCEDURE CAMPUSPROPERTY (VCAMPUS IN VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2);
PROCEDURE USERPROPERTY (VUSERID IN VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2);
PROCEDURE SECURITYGROUPPROPERTY (VSECURITYGROUPNAME IN VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2);

END CORE;
/

show errors

CREATE OR REPLACE PACKAGE BODY CORE AS

FUNCTION CAMPUS(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VCAMPUS IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VISACTIVE IN NUMBER)
RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN
	IF VID IS NULL THEN
		SELECT CAMPUSSEQ.NEXTVAL INTO NID FROM DUAL;
	ELSE 
		NID := VID;
	END IF;

	MERGE INTO CAMPUSES A
	USING (SELECT ID FROM (SELECT ID FROM CAMPUSES WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
	ON (A.ID = B.ID)
	WHEN MATCHED THEN 
	UPDATE SET A.ROWSTAMP = VROWSTAMP, A.CAMPUS = VCAMPUS, A.DESCRIPTION = VDESCRIPTION, A.ISACTIVE = VISACTIVE
	WHEN NOT MATCHED THEN
	INSERT (A.ID, A.ROWSTAMP, A.CAMPUS, A.DESCRIPTION, A.ISACTIVE) VALUES 
		(NID, VROWSTAMP, VCAMPUS, VDESCRIPTION, VISACTIVE);

	IF SQL%ROWCOUNT = 0 THEN
		NID := NULL;
	END IF;

	RETURN NID;
	
END CAMPUS;

PROCEDURE CAMPUS (VCAMPUS IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VISACTIVE IN NUMBER) IS
NID VARCHAR2(10);
BEGIN
	NID := CAMPUS(null, 'AAAA', VCAMPUS, VDESCRIPTION, VISACTIVE);
END CAMPUS; 

FUNCTION LIST (VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VLISTNAME IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VHELPTEXT IN VARCHAR2, VISACTIVE IN NUMBER, VISSYSTEM IN NUMBER) RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN
	IF VID IS NULL THEN 
		SELECT LISTSEQ.NEXTVAL INTO NID FROM DUAL;
	ELSE
		NID := VID;
	END IF;

	MERGE INTO LISTS A
	USING (SELECT ID FROM (SELECT ID FROM LISTS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
	ON (A.ID = B.ID) 
	WHEN MATCHED THEN
	UPDATE SET A.ROWSTAMP=VROWSTAMP, A.LISTNAME=VLISTNAME, A.DESCRIPTION=VDESCRIPTION, A.HELPTEXT=VHELPTEXT, A.ISACTIVE=VISACTIVE, A.ISSYSTEM=VISSYSTEM
	WHEN NOT MATCHED THEN
	INSERT (A.ID, A.ROWSTAMP, A.LISTNAME, A.DESCRIPTION, A.HELPTEXT, A.ISACTIVE, A.ISSYSTEM) VALUES 
		(NID, VROWSTAMP, VLISTNAME, VDESCRIPTION, VHELPTEXT, VISACTIVE, VISSYSTEM);

	IF SQL%ROWCOUNT = 0 THEN
		NID := NULL;
	END IF;

	RETURN NID;

END LIST;

PROCEDURE LIST (VLISTNAME IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VHELPTEXT IN VARCHAR2, VISACTIVE IN NUMBER, VISSYSTEM IN NUMBER) IS
NID VARCHAR2(10);
BEGIN
	NID := LIST(null, 'AAAA', VLISTNAME, VDESCRIPTION, VHELPTEXT, VISACTIVE, VISSYSTEM);
END LIST;

FUNCTION LISTITEM(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VLISTID IN VARCHAR2, VISALLCAMPUS IN NUMBER, VCAMPUSID IN VARCHAR2, VDISPLAYORDER IN NUMBER, VSYSTEMVALUE IN VARCHAR2, VVALUE IN VARCHAR2, VISDEFAULT IN NUMBER, VDESCRIPTION IN VARCHAR2) RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN
	IF VID IS NULL THEN 
		SELECT LISTITEMSEQ.NEXTVAL INTO NID FROM DUAL;
	ELSE
		NID := VID;
	END IF;

	MERGE INTO LISTITEMS A
	USING (SELECT ID FROM (SELECT ID FROM LISTITEMS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
	ON (A.ID = B.ID) 
	WHEN MATCHED THEN
	UPDATE SET A.ROWSTAMP=VROWSTAMP, A.LISTID = VLISTID, A.ISALLCAMPUS=VISALLCAMPUS, A.CAMPUSID = VCAMPUSID, A.DISPLAYORDER=VDISPLAYORDER, A.SYSTEMVALUE = VSYSTEMVALUE, A.VALUE = VVALUE, A.ISDEFAULT=VISDEFAULT, A.DESCRIPTION=VDESCRIPTION
	WHEN NOT MATCHED THEN
	INSERT (A.ID, A.ROWSTAMP, A.LISTID,  A.ISALLCAMPUS, A.CAMPUSID, A.DISPLAYORDER, A.SYSTEMVALUE, A.VALUE, A.ISDEFAULT, A.DESCRIPTION) VALUES
		(NID, VROWSTAMP, VLISTID, VISALLCAMPUS, VCAMPUSID, VDISPLAYORDER, VSYSTEMVALUE, VVALUE, VISDEFAULT, VDESCRIPTION);

	IF SQL%ROWCOUNT = 0 THEN
		NID := NULL;
	END IF;

	RETURN NID;

END LISTITEM;

PROCEDURE LISTITEM (VLISTNAME IN VARCHAR2, VCAMPUS IN VARCHAR2, VISALLCAMPUS IN NUMBER, VDISPLAYORDER IN NUMBER, VSYSTEMVALUE IN VARCHAR2, VVALUE IN VARCHAR2, VISDEFAULT IN NUMBER, VDESCRIPTION IN VARCHAR2) IS
NID VARCHAR2(10);
NID2 VARCHAR2(10);
LLISTID VARCHAR2(10);
LCAMPUSID VARCHAR2(10);
BEGIN
	
	SELECT ID INTO LLISTID FROM LISTS WHERE LISTNAME = VLISTNAME;
	
	IF VISALLCAMPUS = 1 THEN 
		NID := LISTITEM (null, 'AAAA', LLISTID, VISALLCAMPUS, null, VDISPLAYORDER, VSYSTEMVALUE, VVALUE, VISDEFAULT, VDESCRIPTION);
	ELSE
	
		SELECT ID INTO LCAMPUSID FROM CAMPUSES WHERE CAMPUS = VCAMPUS;
		NID := LISTITEM (null, 'AAAA', LLISTID, 0, LCAMPUSID, VDISPLAYORDER, VSYSTEMVALUE, VVALUE, 0, VDESCRIPTION);
		
	END IF;
	
END LISTITEM;


FUNCTION USER(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VUSERLOGIN IN VARCHAR2, 
	VFULLNAME IN VARCHAR2, VSORTNAME IN VARCHAR2, VEMPLID IN VARCHAR2,
	VPASSWORD IN VARCHAR2, VISACTIVE IN NUMBER, VSECRETKEY IN VARCHAR2, 
	VCREATED IN DATE, VCREATEDBY IN VARCHAR2) RETURN VARCHAR2
IS
NID VARCHAR2(10);
BEGIN
		
        IF VID IS NULL THEN 
                SELECT USERSEQ.NEXTVAL INTO NID FROM DUAL;
        ELSE
                NID := VID;
        END IF;

        MERGE INTO USERS A
        USING (SELECT ID FROM (SELECT ID FROM USERS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
        ON (A.ID = B.ID)
        WHEN MATCHED THEN 
        UPDATE SET 
		A.ROWSTAMP=VROWSTAMP, A.USERLOGIN = VUSERLOGIN, 
		A.FULLNAME = VFULLNAME, A.SORTNAME = VSORTNAME,
		A.EMPLID = VEMPLID, A.PASSWORD = VPASSWORD, 
		A.ISACTIVE = VISACTIVE, A.SECRETKEY = VSECRETKEY,
		A.CREATED = VCREATED, A.CREATEDBY = VCREATEDBY
        WHEN NOT MATCHED THEN
        INSERT (
			A.ID, A.ROWSTAMP, A.USERLOGIN, 
			A.FULLNAME, A.SORTNAME, A.EMPLID,
			A.PASSWORD, A.ISACTIVE, A.SECRETKEY,
			A.CREATED, A.CREATEDBY
		) VALUES (
			NID, VROWSTAMP, VUSERLOGIN,
		 	VFULLNAME, VSORTNAME, VEMPLID,
			VPASSWORD, VISACTIVE, VSECRETKEY,
			SYSDATE, VCREATEDBY);

        IF SQL%ROWCOUNT = 0 THEN
                NID := NULL;
        END IF;

        RETURN NID;

	EXCEPTION WHEN OTHERS THEN 
		RETURN NID;


END USER;

FUNCTION USERLOGINHISTORY(VID IN VARCHAR2, VUSERID IN VARCHAR2, VLOGGEDIN IN TIMESTAMP, VIPADDRESS IN VARCHAR2) RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN

	SELECT USERLOGINHISTORYSEQ.NEXTVAL INTO NID FROM DUAL;

	INSERT INTO USERLOGINHISTORY VALUES (NID, VUSERID, VLOGGEDIN, VIPADDRESS);

	RETURN NID;

END USERLOGINHISTORY;

FUNCTION CAMPUSUSER( VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VCAMPUSID IN VARCHAR2, VUSERID IN VARCHAR2) RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN
	
		
        IF VID IS NULL THEN 
                SELECT CAMPUSUSERSEQ.NEXTVAL INTO NID FROM DUAL;
        ELSE
                NID := VID;
        END IF;
        
		IF VCAMPUSID IS NULL OR VUSERID IS NULL THEN
			RETURN NID;
		END IF;
        
       	MERGE INTO CAMPUSUSERS A
        USING (SELECT ID FROM (SELECT ID FROM CAMPUSUSERS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
        ON (A.ID = B.ID)
        WHEN MATCHED THEN        
		UPDATE SET A.ROWSTAMP = VROWSTAMP, A.CAMPUSID = VCAMPUSID, A.USERID = VUSERID
		WHEN NOT MATCHED THEN
		INSERT (A.ID, A.ROWSTAMP, A.CAMPUSID, A.USERID) VALUES 
			(NID, VROWSTAMP, VCAMPUSID, VUSERID);
			
        IF SQL%ROWCOUNT = 0 THEN
                NID := NULL;
        END IF;
        
        RETURN NID;
        
        EXCEPTION 
        	WHEN OTHERS THEN 
        		RETURN NID;
        
END CAMPUSUSER;

PROCEDURE CAMPUSUSER(VCAMPUS IN VARCHAR2, VUSERLOGIN IN VARCHAR2) IS
LCAMPUSID VARCHAR2(10);
LUSERID VARCHAR2(10);
NID VARCHAR2(10);
BEGIN
	SELECT ID INTO LUSERID FROM USERS WHERE USERLOGIN = VUSERLOGIN;
	SELECT ID INTO LCAMPUSID FROM CAMPUSES WHERE CAMPUS = VCAMPUS;
	NID := CAMPUSUSER(null,'AAAA',LCAMPUSID, LUSERID);	
END CAMPUSUSER;

PROCEDURE USER(VUSERLOGIN IN VARCHAR2, VFULLNAME IN VARCHAR2, VSORTNAME IN VARCHAR2, VEMPLID IN VARCHAR2,
	VPASSWORD IN VARCHAR2, VISACTIVE IN NUMBER, VSECRETKEY IN VARCHAR2) IS
NID VARCHAR2(10);
BEGIN
	NID := USER(null, 'AAAA', VUSERLOGIN, VFULLNAME, VSORTNAME, VEMPLID, 
	VPASSWORD, VISACTIVE, null, SYSDATE, '1'); 
END USER;

FUNCTION CRONTASK (VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VJAVACLASS IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VCRONEXPRESSION IN VARCHAR2, VISACTIVE IN NUMBER) RETURN VARCHAR2
IS
NID VARCHAR2(10);
BEGIN
        IF VID IS NULL THEN 
                SELECT CRONTASKSEQ.NEXTVAL INTO NID FROM DUAL;
        ELSE
                NID := VID;
        END IF;
        
       	MERGE INTO CRONTASKS A
        USING (SELECT ID FROM (SELECT ID FROM CRONTASKS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
        ON (A.ID = B.ID)
        WHEN MATCHED THEN        
		UPDATE SET A.ROWSTAMP = VROWSTAMP, A.JAVACLASS = VJAVACLASS, A.DESCRIPTION = VDESCRIPTION, A.CRONEXPRESSION = VCRONEXPRESSION, A.ISACTIVE = VISACTIVE
		WHEN NOT MATCHED THEN
		INSERT (A.ID, A.ROWSTAMP, A.JAVACLASS, A.DESCRIPTION, A.CRONEXPRESSION, A.ISACTIVE) VALUES 
			(NID, VROWSTAMP, VJAVACLASS, VDESCRIPTION, VCRONEXPRESSION, VISACTIVE);
			
        IF SQL%ROWCOUNT = 0 THEN
                NID := NULL;
        END IF;

        RETURN NID;
END CRONTASK;

PROCEDURE CRONTASK(VJAVACLASS IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VCRONEXPRESSION IN VARCHAR2, VISACTIVE IN NUMBER) IS
NID VARCHAR2(10);
BEGIN
		NID := CRONTASK(null,'AAAA', VJAVACLASS, VDESCRIPTION, VCRONEXPRESSION, VISACTIVE);
END CRONTASK;	

FUNCTION CRONTASKRUN(VID IN VARCHAR2, VJAVACLASS IN VARCHAR2, VSERVER IN VARCHAR2, VRUNSTART IN TIMESTAMP, VRUNEND IN TIMESTAMP, VSTATUS IN VARCHAR2, VERROR IN VARCHAR2) RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN

        IF VID IS NULL THEN 
                SELECT CRONTASKRUNSEQ.NEXTVAL INTO NID FROM DUAL;
        ELSE
                NID := VID;
        END IF;
        
       	MERGE INTO CRONTASKRUNS A
        USING (SELECT ID FROM (SELECT ID FROM CRONTASKRUNS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
        ON (A.ID = B.ID)
        WHEN MATCHED THEN        
		UPDATE SET A.JAVACLASS = VJAVACLASS, A.SERVER = VSERVER, A.RUNSTART = VRUNSTART, A.RUNEND = VRUNEND, A.STATUS = VSTATUS, A.ERROR = VERROR
		WHEN NOT MATCHED THEN
		INSERT (A.ID, A.JAVACLASS, A.SERVER, A.RUNSTART, A.RUNEND, A.STATUS, A.ERROR) VALUES 
			(NID, VJAVACLASS, VSERVER, VRUNSTART, VRUNEND, VSTATUS, VERROR);
			
        IF SQL%ROWCOUNT = 0 THEN
                NID := NULL;
        END IF;

        RETURN NID;	
	
	
END CRONTASKRUN;


FUNCTION SECURITYGROUP (VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VSECURITYGROUPNAME IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VISACTIVE IN NUMBER) RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN
        IF VID IS NULL THEN 
                SELECT SECURITYGROUPSEQ.NEXTVAL INTO NID FROM DUAL;
        ELSE
                NID := VID;
        END IF;
        
		MERGE INTO SECURITYGROUPS A
        USING (SELECT ID FROM (SELECT ID FROM SECURITYGROUPS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
        ON (A.ID = B.ID)
        WHEN MATCHED THEN       
		UPDATE SET A.ROWSTAMP = VROWSTAMP, A.SECURITYGROUPNAME = VSECURITYGROUPNAME, A.DESCRIPTION = VDESCRIPTION, A.ISACTIVE = VISACTIVE, A.MODIFIED = SYSDATE
        WHEN NOT MATCHED THEN
		INSERT (A.ID,  A.ROWSTAMP, A.SECURITYGROUPNAME, A.DESCRIPTION, A.ISACTIVE, A.MODIFIED ) VALUES 
			(NID,  VROWSTAMP, VSECURITYGROUPNAME, VDESCRIPTION, VISACTIVE, SYSDATE);
			
        IF SQL%ROWCOUNT = 0 THEN
                NID := NULL;
        END IF;

        RETURN NID;
        
END SECURITYGROUP;


PROCEDURE SECURITYGROUP(VSECURITYGROUPNAME IN VARCHAR2, VDESCRIPTION IN VARCHAR2, VISACTIVE IN NUMBER) IS
NID VARCHAR2(10);
BEGIN
	NID := SECURITYGROUP(null, 'AAAA', VSECURITYGROUPNAME, VDESCRIPTION, VISACTIVE);
END SECURITYGROUP;


FUNCTION SECURITYGROUPUSER(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VSECURITYGROUPID IN VARCHAR2, VUSERID IN VARCHAR2) RETURN VARCHAR2 
IS 
NID VARCHAR2(10);
BEGIN
        IF VID IS NULL THEN 
                SELECT SECURITYGROUPUSERSEQ.NEXTVAL INTO NID FROM DUAL;
        ELSE
                NID := VID;
        END IF;
        
        IF VSECURITYGROUPID IS NULL OR VUSERID IS NULL THEN
        	RETURN NID;
        END IF;
        
       	MERGE INTO SECURITYGROUPUSERS A
        USING (SELECT ID FROM (SELECT ID FROM SECURITYGROUPUSERS WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
        ON (A.ID = B.ID)
        WHEN MATCHED THEN        
		UPDATE SET A.ROWSTAMP = VROWSTAMP, A.SECURITYGROUPID = VSECURITYGROUPID, A.USERID = VUSERID
		WHEN NOT MATCHED THEN
		INSERT (A.ID, A.ROWSTAMP, A.SECURITYGROUPID, A.USERID, A.CREATED) VALUES 
			(NID, VROWSTAMP, VSECURITYGROUPID, VUSERID, SYSDATE);
			
        IF SQL%ROWCOUNT = 0 THEN
                NID := NULL;
        END IF;

        RETURN NID;

	EXCEPTION 
		WHEN OTHERS THEN
			RETURN NID;

END SECURITYGROUPUSER;

PROCEDURE SECURITYGROUPUSER(VSECURITYGROUPNAME IN VARCHAR2, VUSERLOGIN IN VARCHAR2) IS 
NSECURITYGROUPID VARCHAR2(10);
NUSERID VARCHAR2(10);
NID VARCHAR2(10);
BEGIN
	SELECT ID INTO NSECURITYGROUPID FROM SECURITYGROUPS WHERE SECURITYGROUPNAME = VSECURITYGROUPNAME;
	SELECT ID INTO NUSERID FROM USERS WHERE USERLOGIN = VUSERLOGIN;
	NID := SECURITYGROUPUSER(null, 'AAAA', NSECURITYGROUPID, NUSERID);

	EXCEPTION WHEN NO_DATA_FOUND THEN 
		DBMS_OUTPUT.PUT_LINE('ERROR EXECUTING SECURITYGROUPUSER FOR SECURITYGROUP '||VSECURITYGROUPNAME ||' USER '||VUSERLOGIN);
END SECURITYGROUPUSER;



FUNCTION PROPERTY(VID IN VARCHAR2, VROWSTAMP IN VARCHAR2, VREFIDTYPE IN VARCHAR2, VREFID IN VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2)
RETURN VARCHAR2 IS
NID VARCHAR2(10);
BEGIN
	IF VID IS NULL THEN
		SELECT PROPERTYSEQ.NEXTVAL INTO NID FROM DUAL;
	ELSE 
		NID := VID;
	END IF;

	MERGE INTO PROPERTIES A
	USING (SELECT ID FROM (SELECT ID FROM PROPERTIES WHERE ID = NID UNION ALL SELECT NULL ID FROM DUAL) WHERE ROWNUM = 1) B
	ON (A.ID = B.ID)
	WHEN MATCHED THEN 
	UPDATE SET A.ROWSTAMP = VROWSTAMP, A.REFIDTYPE = VREFIDTYPE, A.REFID = VREFID, A.PROPERTY = VPROPERTY, A.VALUE = VVALUE
	WHEN NOT MATCHED THEN
	INSERT (A.ID, A.ROWSTAMP, A.REFIDTYPE, A.REFID, A.PROPERTY, A.VALUE) VALUES 
		(NID, VROWSTAMP, VREFIDTYPE, VREFID, VPROPERTY, VVALUE);

	IF SQL%ROWCOUNT = 0 THEN
		NID := NULL;
	END IF;

	RETURN NID;
	
END PROPERTY;

PROCEDURE SYSTEMPROPERTY (VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2) IS
NID VARCHAR2(10);
BEGIN
	NID := PROPERTY(null,'AAAA','SYSTEM',null,VPROPERTY, VVALUE);
END SYSTEMPROPERTY;

PROCEDURE CAMPUSPROPERTY (VCAMPUS IN VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2) IS
NID VARCHAR2(10);
NREFID VARCHAR2(10);
BEGIN
	SELECT ID INTO NREFID FROM CAMPUSES WHERE CAMPUS = VCAMPUS;
	NID := PROPERTY(null,'AAAA', 'CAMPUS', NREFID, VPROPERTY, VVALUE);
END CAMPUSPROPERTY;

PROCEDURE USERPROPERTY (VUSERID IN VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2) IS 
NID VARCHAR2(10);
BEGIN
	NID := PROPERTY(null,'AAAA', 'USER', VUSERID, VPROPERTY, VVALUE);
END USERPROPERTY;

PROCEDURE SECURITYGROUPPROPERTY (VSECURITYGROUPNAME IN VARCHAR2, VPROPERTY IN VARCHAR2, VVALUE IN VARCHAR2) IS 
NID VARCHAR2(10);
NREFID VARCHAR2(10);
BEGIN
	SELECT ID INTO NREFID FROM SECURITYGROUPS WHERE SECURITYGROUPNAME = VSECURITYGROUPNAME;
	NID := PROPERTY(null,'AAAA', 'SECURITYGROUP', NREFID, VPROPERTY, VVALUE);
END SECURITYGROUPPROPERTY;

END CORE;
/

show errors;

EXECUTE CORE.USER('REPORTCENTER', 'REPORTCENTER', 'REPORTCENTER', null, null, 1, null);

COMMIT;
